<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Voice ‚Üí CC (Android)</title>
    <style>
      :root { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
      body { margin: 0; background: #0b0c0f; color: #e5e7eb; }
      .wrap { max-width: 720px; margin: 0 auto; padding: 12px; }
      h1 { font-size: 18px; margin: 8px 0 12px; font-weight: 700;}
      .controls { display:flex; gap:8px; margin-bottom: 12px; flex-wrap: wrap; }
      button { background:#111827; border:1px solid #374151; color:#e5e7eb; padding:10px 12px; border-radius: 12px; font-size:16px; cursor:pointer; }
      button.primary { background:#2563eb; border-color:#1d4ed8; }
      button[disabled] { opacity:0.5; cursor:not-allowed; }
      .status { font-size: 13px; opacity:.8; margin: 6px 0 8px; min-height: 18px;}
      .panes { display:grid; grid-template-columns: 1fr; gap:10px; }
      .pane { background:#0f172a; border:1px solid #1f2937; border-radius: 14px; padding:12px; min-height: 120px;}
      .pane h2 { font-size:14px; margin:0 0 8px; color:#93c5fd; }
      .text { white-space: pre-wrap; line-height: 1.5; font-size:16px;}
      .pill { display:inline-block; padding:4px 8px; font-size:12px; border-radius:999px; background:#1f2937; border:1px solid #374151; margin-left:8px;}
      .badge { font-size: 12px; opacity: .8; }
      .muted { opacity:.6 }
    </style>
  </head>
  <body>
    <div class="wrap">
      <h1>Realtime Voice ‚Üí <span class="badge">Captions (no voice out)</span></h1>
      <div class="controls">
        <button id="start" class="primary">Start session</button>
        <button id="mic" disabled>üéôÔ∏è Mic: <span id="micState">Off</span></button>
        <button id="clear" disabled>Clear</button>
      </div>
      <div class="status" id="status">Ready.</div>

      <div class="panes">
        <div class="pane">
          <h2>You <span class="pill" id="vad">idle</span></h2>
          <div class="text" id="you"></div>
        </div>
        <div class="pane">
          <h2>Assistant</h2>
          <div class="text" id="assistant"></div>
        </div>
      </div>
      <div class="badge">Tip: Keep session open; just toggle Mic to speak again.</div>
    </div>

    <script>
      // Set to your deployed server URL in production (HTTPS)
      // Example: const API_BASE = "https://your-api.onrender.com";
      const API_BASE = "https://voice-cc-worker.abbas-voice.workers.dev";

      const $ = (id) => document.getElementById(id);
      const statusEl = $("status");
      const youEl = $("you");
      const asstEl = $("assistant");
      const vadEl = $("vad");
      const startBtn = $("start");
      const micBtn = $("mic");
      const clearBtn = $("clear");
      const micStateEl = $("micState");

      let pc, dc, localStream, micTrack, sessionActive = false;

      async function startSession() {
        try {
          startBtn.disabled = true;
          statusEl.textContent = "Requesting mic‚Ä¶";
          localStream = await navigator.mediaDevices.getUserMedia({
            audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
          });
          micTrack = localStream.getAudioTracks()[0];
          updateMicUI(false);

          statusEl.textContent = "Creating peer connection‚Ä¶";
          pc = new RTCPeerConnection();
          pc.addTrack(micTrack, localStream);
          micTrack.enabled = false;

          dc = pc.createDataChannel("oai-events");
          dc.onopen = onDataChannelOpen;
          dc.onmessage = onDataChannelMessage;
          dc.onerror = (e) => console.error("DC error", e);

          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);

          statusEl.textContent = "Fetching ephemeral session‚Ä¶";
          const tokenRes = await fetch(`${API_BASE}/session`);
          if (!tokenRes.ok) throw new Error("Failed to mint session: " + await tokenRes.text());
          const tokenData = await tokenRes.json();
          const EPHEMERAL_KEY = tokenData.client_secret?.value;
          if (!EPHEMERAL_KEY) throw new Error("Missing ephemeral key");

          statusEl.textContent = "Exchanging SDP with OpenAI‚Ä¶";
          const baseUrl = "https://api.openai.com/v1/realtime";
          const model = tokenData.model || "gpt-4o-realtime-preview";
          const sdpResponse = await fetch(`${baseUrl}?model=${encodeURIComponent(model)}`, {
            method: "POST",
            body: offer.sdp,
            headers: {
              "Authorization": `Bearer ${EPHEMERAL_KEY}`,
              "Content-Type": "application/sdp",
              "OpenAI-Beta": "realtime=v1"
            }
          });
          const answer = { type: "answer", sdp: await sdpResponse.text() };
          await pc.setRemoteDescription(answer);

          micBtn.disabled = false;
          clearBtn.disabled = false;
          statusEl.textContent = "Session connected. Toggle Mic to start speaking.";

        } catch (err) {
          console.error(err);
          statusEl.textContent = "Error: " + err.message;
          startBtn.disabled = false;
        }
      }

      function onDataChannelOpen() {
        const msg = {
          type: "session.update",
          session: {
            modalities: ["text"],
            input_audio_transcription: { model: "whisper-1" },
            turn_detection: { type: "server_vad", silence_duration_ms: 300, create_response: true },
            instructions: "You are a fast, concise realtime assistant. Reply as short text."
          }
        };
        dc.send(JSON.stringify(msg));
      }

      function onDataChannelMessage(ev) {
        try {
          const event = JSON.parse(ev.data);

          if (event.type === "input_audio_buffer.speech_started") {
            vadEl.textContent = "listening‚Ä¶";
          }
          if (event.type === "input_audio_buffer.speech_stopped") {
            vadEl.textContent = "processing‚Ä¶";
          }
          if (event.type === "conversation.item.input_audio_transcription.completed") {
            const text = event.transcript?.text || event.item?.content?.[0]?.transcript?.text || "";
            if (text) {
              youEl.textContent = (youEl.textContent + (youEl.textContent ? "\n" : "") + text).trim();
              vadEl.textContent = "idle";
            }
          }
          if (event.type === "response.text.delta" || event.type === "response.output_text.delta") {
            asstEl.textContent += event.delta || event.text || "";
          }
          if (event.type === "response.text.done" || event.type === "response.done") {
            asstEl.textContent += "\n";
          }
          if (event.type === "error") {
            statusEl.textContent = "Realtime error: " + (event.error?.message || "unknown");
          }
        } catch (e) {
          console.error("Failed to parse event", e, ev.data);
        }
      }

      function updateMicUI(isOn) {
        micStateEl.textContent = isOn ? "On" : "Off";
        micBtn.classList.toggle("primary", isOn);
        vadEl.classList.toggle("muted", !isOn);
      }

      document.getElementById("start").addEventListener("click", startSession);
      document.getElementById("mic").addEventListener("click", () => {
        if (!micTrack) return;
        const newState = !micTrack.enabled;
        micTrack.enabled = newState;
        updateMicUI(newState);
        statusEl.textContent = newState ? "Mic ON ‚Äî speak now." : "Mic OFF.";
      });
      document.getElementById("clear").addEventListener("click", () => {
        youEl.textContent = "";
        asstEl.textContent = "";
      });
    </script>
  </body>
</html>
